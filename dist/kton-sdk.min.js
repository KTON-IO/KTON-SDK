!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@ton/core")):"function"==typeof define&&define.amd?define(["exports","@ton/core"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).KTONSDK={},t.TonCore)}(this,function(t,e){"use strict";var o,s=Object.defineProperty,a=(t,e,o)=>((t,e,o)=>e in t?s(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o)(t,"symbol"!=typeof e?e+"":e,o),r={};var n,i,c,h,l,d,u,p,m,g,f,y,v,w,T,k,b,j,E=(o||(o=1,Object.defineProperty(r,"__esModule",{value:!0}),r.Api=r.HttpClient=r.ContentType=r.PoolImplementationType=r.TrustType=r.JettonVerificationType=r.BouncePhaseType=r.ComputeSkipReason=r.AccStatusChange=r.TransactionType=r.AccountStatus=void 0,(i=n||(r.AccountStatus=n={})).Nonexist="nonexist",i.Uninit="uninit",i.Active="active",i.Frozen="frozen",(h=c||(r.TransactionType=c={})).TransOrd="TransOrd",h.TransTickTock="TransTickTock",h.TransSplitPrepare="TransSplitPrepare",h.TransSplitInstall="TransSplitInstall",h.TransMergePrepare="TransMergePrepare",h.TransMergeInstall="TransMergeInstall",h.TransStorage="TransStorage",(d=l||(r.AccStatusChange=l={})).AcstUnchanged="acst_unchanged",d.AcstFrozen="acst_frozen",d.AcstDeleted="acst_deleted",(p=u||(r.ComputeSkipReason=u={})).CskipNoState="cskip_no_state",p.CskipBadState="cskip_bad_state",p.CskipNoGas="cskip_no_gas",p.CskipSuspended="cskip_suspended",(g=m||(r.BouncePhaseType=m={})).TrPhaseBounceNegfunds="TrPhaseBounceNegfunds",g.TrPhaseBounceNofunds="TrPhaseBounceNofunds",g.TrPhaseBounceOk="TrPhaseBounceOk",(y=f||(r.JettonVerificationType=f={})).Whitelist="whitelist",y.Blacklist="blacklist",y.None="none",(w=v||(r.TrustType=v={})).Whitelist="whitelist",w.Graylist="graylist",w.Blacklist="blacklist",w.None="none",(k=T||(r.PoolImplementationType=T={})).Whales="whales",k.Tf="tf",k.LiquidTF="liquidTF",(j=b||(r.ContentType=b={})).Json="application/json",j.FormData="multipart/form-data",j.UrlEncoded="application/x-www-form-urlencoded",j.Text="text/plain",r.HttpClient=class{constructor(t={}){a(this,"baseUrl","https://tonapi.io"),a(this,"securityData",null),a(this,"securityWorker"),a(this,"abortControllers",new Map),a(this,"customFetch",(...t)=>fetch(...t)),a(this,"baseApiParams",{credentials:"same-origin",headers:{},redirect:"follow",referrerPolicy:"no-referrer"}),a(this,"setSecurityData",t=>{this.securityData=t}),a(this,"contentFormatters",{[b.Json]:t=>null===t||"object"!=typeof t&&"string"!=typeof t?t:JSON.stringify(t),[b.Text]:t=>null!==t&&"string"!=typeof t?JSON.stringify(t):t,[b.FormData]:t=>Object.keys(t||{}).reduce((e,o)=>{const s=t[o];return e.append(o,s instanceof Blob?s:"object"==typeof s&&null!==s?JSON.stringify(s):`${s}`),e},new FormData),[b.UrlEncoded]:t=>this.toQueryString(t)}),a(this,"createAbortSignal",t=>{if(this.abortControllers.has(t)){const e=this.abortControllers.get(t);return e?e.signal:void 0}const e=new AbortController;return this.abortControllers.set(t,e),e.signal}),a(this,"abortRequest",t=>{const e=this.abortControllers.get(t);e&&(e.abort(),this.abortControllers.delete(t))}),a(this,"request",async({body:t,secure:e,path:o,type:s,query:a,format:r,baseUrl:n,cancelToken:i,...c})=>{const h=("boolean"==typeof e?e:this.baseApiParams.secure)&&this.securityWorker&&await this.securityWorker(this.securityData)||{},l=this.mergeRequestParams(c,h),d=a&&this.toQueryString(a),u=this.contentFormatters[s||b.Json],p=r||l.format;return this.customFetch(`${n||this.baseUrl||""}${o}${d?`?${d}`:""}`,{...l,headers:{...l.headers||{},...s&&s!==b.FormData?{"Content-Type":s}:{}},signal:(i?this.createAbortSignal(i):l.signal)||null,body:null==t?null:u(t)}).then(async t=>{const e=t.clone();e.data=null,e.error=null;const o=p?await t[p]().then(t=>(e.ok?e.data=t:e.error=t,e)).catch(t=>(e.error=t,e)):e;if(i&&this.abortControllers.delete(i),!t.ok)throw o;return o.data})}),Object.assign(this,t)}encodeQueryParam(t,e){return`${encodeURIComponent(t)}=${encodeURIComponent("number"==typeof e?e:`${e}`)}`}addQueryParam(t,e){return this.encodeQueryParam(e,t[e])}addArrayQueryParam(t,e){return t[e].map(t=>this.encodeQueryParam(e,t)).join("&")}toQueryString(t){const e=t||{};return Object.keys(e).filter(t=>void 0!==e[t]).map(t=>Array.isArray(e[t])?this.addArrayQueryParam(e,t):this.addQueryParam(e,t)).join("&")}addQueryParams(t){const e=this.toQueryString(t);return e?`?${e}`:""}mergeRequestParams(t,e){return{...this.baseApiParams,...t,...e||{},headers:{...this.baseApiParams.headers||{},...t.headers||{},...e&&e.headers||{}}}}},r.Api=class{constructor(t){a(this,"http"),a(this,"utilities",{getOpenapiJson:(t={})=>this.http.request({path:"/v2/openapi.json",method:"GET",format:"json",...t}),getOpenapiYml:(t={})=>this.http.request({path:"/v2/openapi.yml",method:"GET",...t}),status:(t={})=>this.http.request({path:"/v2/status",method:"GET",format:"json",...t}),addressParse:(t,e={})=>this.http.request({path:`/v2/address/${t}/parse`,method:"GET",format:"json",...e})}),a(this,"blockchain",{getReducedBlockchainBlocks:(t,e={})=>this.http.request({path:"/v2/blockchain/reduced/blocks",method:"GET",query:t,format:"json",...e}),getBlockchainBlock:(t,e={})=>this.http.request({path:`/v2/blockchain/blocks/${t}`,method:"GET",format:"json",...e}),downloadBlockchainBlockBoc:(t,e={})=>this.http.request({path:`/v2/blockchain/blocks/${t}/boc`,method:"GET",...e}),getBlockchainMasterchainShards:(t,e={})=>this.http.request({path:`/v2/blockchain/masterchain/${t}/shards`,method:"GET",format:"json",...e}),getBlockchainMasterchainBlocks:(t,e={})=>this.http.request({path:`/v2/blockchain/masterchain/${t}/blocks`,method:"GET",format:"json",...e}),getBlockchainMasterchainTransactions:(t,e={})=>this.http.request({path:`/v2/blockchain/masterchain/${t}/transactions`,method:"GET",format:"json",...e}),getBlockchainConfigFromBlock:(t,e={})=>this.http.request({path:`/v2/blockchain/masterchain/${t}/config`,method:"GET",format:"json",...e}),getRawBlockchainConfigFromBlock:(t,e={})=>this.http.request({path:`/v2/blockchain/masterchain/${t}/config/raw`,method:"GET",format:"json",...e}),getBlockchainBlockTransactions:(t,e={})=>this.http.request({path:`/v2/blockchain/blocks/${t}/transactions`,method:"GET",format:"json",...e}),getBlockchainTransaction:(t,e={})=>this.http.request({path:`/v2/blockchain/transactions/${t}`,method:"GET",format:"json",...e}),getBlockchainTransactionByMessageHash:(t,e={})=>this.http.request({path:`/v2/blockchain/messages/${t}/transaction`,method:"GET",format:"json",...e}),getBlockchainValidators:(t={})=>this.http.request({path:"/v2/blockchain/validators",method:"GET",format:"json",...t}),getBlockchainMasterchainHead:(t={})=>this.http.request({path:"/v2/blockchain/masterchain-head",method:"GET",format:"json",...t}),getBlockchainRawAccount:(t,e={})=>this.http.request({path:`/v2/blockchain/accounts/${t}`,method:"GET",format:"json",...e}),getBlockchainAccountTransactions:(t,e,o={})=>this.http.request({path:`/v2/blockchain/accounts/${t}/transactions`,method:"GET",query:e,format:"json",...o}),execGetMethodForBlockchainAccount:(t,e,o,s={})=>this.http.request({path:`/v2/blockchain/accounts/${t}/methods/${e}`,method:"GET",query:o,format:"json",...s}),sendBlockchainMessage:(t,e={})=>this.http.request({path:"/v2/blockchain/message",method:"POST",body:t,...e}),getBlockchainConfig:(t={})=>this.http.request({path:"/v2/blockchain/config",method:"GET",format:"json",...t}),getRawBlockchainConfig:(t={})=>this.http.request({path:"/v2/blockchain/config/raw",method:"GET",format:"json",...t}),blockchainAccountInspect:(t,e={})=>this.http.request({path:`/v2/blockchain/accounts/${t}/inspect`,method:"GET",format:"json",...e})}),a(this,"accounts",{getAccounts:(t,e,o={})=>this.http.request({path:"/v2/accounts/_bulk",method:"POST",query:e,body:t,format:"json",...o}),getAccount:(t,e={})=>this.http.request({path:`/v2/accounts/${t}`,method:"GET",format:"json",...e}),accountDnsBackResolve:(t,e={})=>this.http.request({path:`/v2/accounts/${t}/dns/backresolve`,method:"GET",format:"json",...e}),getAccountJettonsBalances:(t,e,o={})=>this.http.request({path:`/v2/accounts/${t}/jettons`,method:"GET",query:e,format:"json",...o}),getAccountJettonBalance:(t,e,o,s={})=>this.http.request({path:`/v2/accounts/${t}/jettons/${e}`,method:"GET",query:o,format:"json",...s}),getAccountJettonsHistory:(t,e,o={})=>this.http.request({path:`/v2/accounts/${t}/jettons/history`,method:"GET",query:e,format:"json",...o}),getAccountJettonHistoryById:(t,e,o,s={})=>this.http.request({path:`/v2/accounts/${t}/jettons/${e}/history`,method:"GET",query:o,format:"json",...s}),getAccountNftItems:(t,e,o={})=>this.http.request({path:`/v2/accounts/${t}/nfts`,method:"GET",query:e,format:"json",...o}),getAccountEvents:(t,e,o={})=>this.http.request({path:`/v2/accounts/${t}/events`,method:"GET",query:e,format:"json",...o}),getAccountEvent:(t,e,o,s={})=>this.http.request({path:`/v2/accounts/${t}/events/${e}`,method:"GET",query:o,format:"json",...s}),getAccountTraces:(t,e,o={})=>this.http.request({path:`/v2/accounts/${t}/traces`,method:"GET",query:e,format:"json",...o}),getAccountSubscriptions:(t,e={})=>this.http.request({path:`/v2/accounts/${t}/subscriptions`,method:"GET",format:"json",...e}),reindexAccount:(t,e={})=>this.http.request({path:`/v2/accounts/${t}/reindex`,method:"POST",...e}),searchAccounts:(t,e={})=>this.http.request({path:"/v2/accounts/search",method:"GET",query:t,format:"json",...e}),getAccountDnsExpiring:(t,e,o={})=>this.http.request({path:`/v2/accounts/${t}/dns/expiring`,method:"GET",query:e,format:"json",...o}),getAccountPublicKey:(t,e={})=>this.http.request({path:`/v2/accounts/${t}/publickey`,method:"GET",format:"json",...e}),getAccountMultisigs:(t,e={})=>this.http.request({path:`/v2/accounts/${t}/multisigs`,method:"GET",format:"json",...e}),getAccountDiff:(t,e,o={})=>this.http.request({path:`/v2/accounts/${t}/diff`,method:"GET",query:e,format:"json",...o}),getAccountExtraCurrencyHistoryById:(t,e,o,s={})=>this.http.request({path:`/v2/accounts/${t}/extra-currency/${e}/history`,method:"GET",query:o,format:"json",...s})}),a(this,"nft",{getAccountNftHistory:(t,e,o={})=>this.http.request({path:`/v2/accounts/${t}/nfts/history`,method:"GET",query:e,format:"json",...o}),getNftCollections:(t,e={})=>this.http.request({path:"/v2/nfts/collections",method:"GET",query:t,format:"json",...e}),getNftCollection:(t,e={})=>this.http.request({path:`/v2/nfts/collections/${t}`,method:"GET",format:"json",...e}),getNftCollectionItemsByAddresses:(t,e={})=>this.http.request({path:"/v2/nfts/collections/_bulk",method:"POST",body:t,format:"json",...e}),getItemsFromCollection:(t,e,o={})=>this.http.request({path:`/v2/nfts/collections/${t}/items`,method:"GET",query:e,format:"json",...o}),getNftItemsByAddresses:(t,e={})=>this.http.request({path:"/v2/nfts/_bulk",method:"POST",body:t,format:"json",...e}),getNftItemByAddress:(t,e={})=>this.http.request({path:`/v2/nfts/${t}`,method:"GET",format:"json",...e}),getNftHistoryById:(t,e,o={})=>this.http.request({path:`/v2/nfts/${t}/history`,method:"GET",query:e,format:"json",...o})}),a(this,"dns",{getDnsInfo:(t,e={})=>this.http.request({path:`/v2/dns/${t}`,method:"GET",format:"json",...e}),dnsResolve:(t,e={})=>this.http.request({path:`/v2/dns/${t}/resolve`,method:"GET",format:"json",...e}),getDomainBids:(t,e={})=>this.http.request({path:`/v2/dns/${t}/bids`,method:"GET",format:"json",...e}),getAllAuctions:(t,e={})=>this.http.request({path:"/v2/dns/auctions",method:"GET",query:t,format:"json",...e})}),a(this,"traces",{getTrace:(t,e={})=>this.http.request({path:`/v2/traces/${t}`,method:"GET",format:"json",...e})}),a(this,"events",{getEvent:(t,e={})=>this.http.request({path:`/v2/events/${t}`,method:"GET",format:"json",...e})}),a(this,"jettons",{getJettons:(t,e={})=>this.http.request({path:"/v2/jettons",method:"GET",query:t,format:"json",...e}),getJettonInfo:(t,e={})=>this.http.request({path:`/v2/jettons/${t}`,method:"GET",format:"json",...e}),getJettonInfosByAddresses:(t,e={})=>this.http.request({path:"/v2/jettons/_bulk",method:"POST",body:t,format:"json",...e}),getJettonHolders:(t,e,o={})=>this.http.request({path:`/v2/jettons/${t}/holders`,method:"GET",query:e,format:"json",...o}),getJettonTransferPayload:(t,e,o={})=>this.http.request({path:`/v2/jettons/${e}/transfer/${t}/payload`,method:"GET",format:"json",...o}),getJettonsEvents:(t,e={})=>this.http.request({path:`/v2/events/${t}/jettons`,method:"GET",format:"json",...e})}),a(this,"extraCurrency",{getExtraCurrencyInfo:(t,e={})=>this.http.request({path:`/v2/extra-currency/${t}`,method:"GET",format:"json",...e})}),a(this,"staking",{getAccountNominatorsPools:(t,e={})=>this.http.request({path:`/v2/staking/nominator/${t}/pools`,method:"GET",format:"json",...e}),getStakingPoolInfo:(t,e={})=>this.http.request({path:`/v2/staking/pool/${t}`,method:"GET",format:"json",...e}),getStakingPoolHistory:(t,e={})=>this.http.request({path:`/v2/staking/pool/${t}/history`,method:"GET",format:"json",...e}),getStakingPools:(t,e={})=>this.http.request({path:"/v2/staking/pools",method:"GET",query:t,format:"json",...e})}),a(this,"storage",{getStorageProviders:(t={})=>this.http.request({path:"/v2/storage/providers",method:"GET",format:"json",...t})}),a(this,"rates",{getRates:(t,e={})=>this.http.request({path:"/v2/rates",method:"GET",query:t,format:"json",...e}),getChartRates:(t,e={})=>this.http.request({path:"/v2/rates/chart",method:"GET",query:t,format:"json",...e}),getMarketsRates:(t={})=>this.http.request({path:"/v2/rates/markets",method:"GET",format:"json",...t})}),a(this,"connect",{getTonConnectPayload:(t={})=>this.http.request({path:"/v2/tonconnect/payload",method:"GET",format:"json",...t}),getAccountInfoByStateInit:(t,e={})=>this.http.request({path:"/v2/tonconnect/stateinit",method:"POST",body:t,format:"json",...e})}),a(this,"wallet",{tonConnectProof:(t,e={})=>this.http.request({path:"/v2/wallet/auth/proof",method:"POST",body:t,format:"json",...e}),getAccountSeqno:(t,e={})=>this.http.request({path:`/v2/wallet/${t}/seqno`,method:"GET",format:"json",...e}),getWalletsByPublicKey:(t,e={})=>this.http.request({path:`/v2/pubkeys/${t}/wallets`,method:"GET",format:"json",...e})}),a(this,"gasless",{gaslessConfig:(t={})=>this.http.request({path:"/v2/gasless/config",method:"GET",format:"json",...t}),gaslessEstimate:(t,e,o={})=>this.http.request({path:`/v2/gasless/estimate/${t}`,method:"POST",body:e,format:"json",...o}),gaslessSend:(t,e={})=>this.http.request({path:"/v2/gasless/send",method:"POST",body:t,format:"json",...e})}),a(this,"liteServer",{getRawMasterchainInfo:(t={})=>this.http.request({path:"/v2/liteserver/get_masterchain_info",method:"GET",format:"json",...t}),getRawMasterchainInfoExt:(t,e={})=>this.http.request({path:"/v2/liteserver/get_masterchain_info_ext",method:"GET",query:t,format:"json",...e}),getRawTime:(t={})=>this.http.request({path:"/v2/liteserver/get_time",method:"GET",format:"json",...t}),getRawBlockchainBlock:(t,e={})=>this.http.request({path:`/v2/liteserver/get_block/${t}`,method:"GET",format:"json",...e}),getRawBlockchainBlockState:(t,e={})=>this.http.request({path:`/v2/liteserver/get_state/${t}`,method:"GET",format:"json",...e}),getRawBlockchainBlockHeader:(t,e,o={})=>this.http.request({path:`/v2/liteserver/get_block_header/${t}`,method:"GET",query:e,format:"json",...o}),sendRawMessage:(t,e={})=>this.http.request({path:"/v2/liteserver/send_message",method:"POST",body:t,format:"json",...e}),getRawAccountState:(t,e,o={})=>this.http.request({path:`/v2/liteserver/get_account_state/${t}`,method:"GET",query:e,format:"json",...o}),getRawShardInfo:(t,e,o={})=>this.http.request({path:`/v2/liteserver/get_shard_info/${t}`,method:"GET",query:e,format:"json",...o}),getAllRawShardsInfo:(t,e={})=>this.http.request({path:`/v2/liteserver/get_all_shards_info/${t}`,method:"GET",format:"json",...e}),getRawTransactions:(t,e,o={})=>this.http.request({path:`/v2/liteserver/get_transactions/${t}`,method:"GET",query:e,format:"json",...o}),getRawListBlockTransactions:(t,e,o={})=>this.http.request({path:`/v2/liteserver/list_block_transactions/${t}`,method:"GET",query:e,format:"json",...o}),getRawBlockProof:(t,e={})=>this.http.request({path:"/v2/liteserver/get_block_proof",method:"GET",query:t,format:"json",...e}),getRawConfig:(t,e,o={})=>this.http.request({path:`/v2/liteserver/get_config_all/${t}`,method:"GET",query:e,format:"json",...o}),getRawShardBlockProof:(t,e={})=>this.http.request({path:`/v2/liteserver/get_shard_block_proof/${t}`,method:"GET",format:"json",...e}),getOutMsgQueueSizes:(t={})=>this.http.request({path:"/v2/liteserver/get_out_msg_queue_sizes",method:"GET",format:"json",...t})}),a(this,"multisig",{getMultisigAccount:(t,e={})=>this.http.request({path:`/v2/multisig/${t}`,method:"GET",format:"json",...e})}),a(this,"emulation",{decodeMessage:(t,e={})=>this.http.request({path:"/v2/message/decode",method:"POST",body:t,format:"json",...e}),emulateMessageToEvent:(t,e,o={})=>this.http.request({path:"/v2/events/emulate",method:"POST",query:e,body:t,format:"json",...o}),emulateMessageToTrace:(t,e,o={})=>this.http.request({path:"/v2/traces/emulate",method:"POST",query:e,body:t,format:"json",...o}),emulateMessageToWallet:(t,e={})=>this.http.request({path:"/v2/wallet/emulate",method:"POST",body:t,format:"json",...e}),emulateMessageToAccountEvent:(t,e,o,s={})=>this.http.request({path:`/v2/accounts/${t}/events/emulate`,method:"POST",query:o,body:e,format:"json",...s})}),this.http=t}}),r);const q=6e5,S=3e4,A=3,P=600,B="-3",$="https://tonapi.io",G="https://testnet.tonapi.io",C="https://toncenter.com/api/v3",N="https://jetton-index.tonscan.org/public-dyor",I="EQA9HwEZD_tONfVz6lJS0PVKR5viEiEGyj9AuQewGQVnXPg0",_="kQD2y9eUotYw7VprrD0UJvAigDVXwgCCLWAl-DjaamCHniVr",O=1953787758,F=1499400124,D=1205158801,x=1,R=1.05,M=1.1,J=JSON.stringify;JSON.stringify=function(t,e,o){return J(t,(t,o)=>"bigint"==typeof o?o.toString()+"n":"function"==typeof e?e(t,o):Array.isArray(e)?""===t||e.includes(t)?o:void 0:o,o)};const W=JSON.parse;JSON.parse=function(t,e){return W(t,(t,o)=>"string"==typeof o&&/^-?\d+n$/.test(o)?BigInt(o.slice(0,-1)):"function"==typeof e?e(t,o):o)};class z{constructor(t,e="network-cache-"){this.defaultTtl=t,this.prefix=e}get time(){return Date.now()}async get(t,e,o){const s=this.getFullKey(t);return this.needsUpdate(s)?this.save(s,e(),o):this.retrieve(s)}needsUpdate(t,e){if(e)return e;const o=this.getDataPiece(t);return!o||this.time-o.ts>=o.ttl}async retrieve(t){const e=this.getDataPiece(t);if(!e)throw new Error("Data not found");try{const t=JSON.parse(e.data);return this.deserializeData(t)}catch(o){throw console.error(`Failed to parse cached data for key ${t}:`,o),new Error("Invalid cached data")}}async save(t,e,o){try{const s=e instanceof Promise?await e:e;if(null==s)return console.warn(`Skipping cache save for ${t}: data is ${String(s)}`),s;const a=this.sanitizeForSerialization(s),r=JSON.stringify(a),n={ts:this.time,ttl:o??this.defaultTtl,data:r};return localStorage.setItem(t,JSON.stringify(n)),s}catch(s){console.error("Failed to save data:",s);return e instanceof Promise?await e:e}}pop(t){const e=this.getFullKey(t),o=this.getDataPiece(e);return localStorage.removeItem(e),o?JSON.parse(o.data):void 0}get size(){return Object.keys(localStorage).filter(t=>t.startsWith(this.prefix)).length}cleanup(){Object.keys(localStorage).forEach(t=>{if(t.startsWith(this.prefix)){this.getDataPiece(t)&&this.needsUpdate(t)&&this.pop(t)}})}clear(t){t?Object.keys(localStorage).forEach(e=>{if(e.startsWith(this.prefix)){const o=e.split("-").slice(0,3).join("-");t.some(t=>o===t)&&localStorage.removeItem(e)}}):Object.keys(localStorage).forEach(t=>{t.startsWith(this.prefix)&&localStorage.removeItem(t)})}getFullKey(t){return`${this.prefix}${t}`}getDataPiece(t){try{const e=localStorage.getItem(t);return e?JSON.parse(e):null}catch(e){return console.error(`Failed to parse data for key ${t}:`,e),null}}sanitizeForSerialization(t){if(null==t)return t;if("bigint"==typeof t)return{__type:"bigint",value:t.toString()};if(t instanceof Date)return{__type:"Date",value:t.toISOString()};if(Array.isArray(t))return t.map(t=>this.sanitizeForSerialization(t));if("object"==typeof t){const e={};for(const[o,s]of Object.entries(t))e[o]=this.sanitizeForSerialization(s);return e}return t}deserializeData(t){if(null===t||"object"!=typeof t)return t;if("bigint"===t.__type&&"string"==typeof t.value)return BigInt(t.value);if("Date"===t.__type&&"string"==typeof t.value)return new Date(t.value);if(Array.isArray(t))return t.map(t=>this.deserializeData(t));const e={};for(const[o,s]of Object.entries(t))e[o]=this.deserializeData(s);return e}}const H=(...t)=>{(()=>{if("undefined"==typeof window)return!1;const t=window.location;if(!t)return!1;const e=t.hostname;return"localhost"===e||"127.0.0.1"===e||e.includes("preview")})()&&console.log(...t)};class U extends EventTarget{constructor({connector:t,partnerCode:e=O,tonApiKey:o,cacheFor:s,isTestnet:a=!1}){super(),this.connector=t,this.partnerCode=e,this.tonApiKey=o,this.cache=new z(void 0===s?S:s),this.ready=!1,this.isTestnet=a,this.setupClient(),this.initialize().catch(t=>{console.error("Initialization error:",t)})}async getPayouts(){try{const t=await this.fetchStakingPoolInfo(),e=Math.floor(Date.now()/1e3)+65536;return{deposit_payout:t.depositPayout?t.depositPayout.toString():"",deposit_amount:t.requestedForDeposit.toString(),withdrawal_payout:t.withdrawalPayout?t.withdrawalPayout.toString():"",withdrawal_amount:t.requestedForWithdrawal.toString(),cycle_end:e.toString()}}catch(t){return void console.error("Error fetching withdrawal payouts:",t)}}async setupClient(){H("Setting up KTON SDK, isTestnet:",this.isTestnet);const t=this.tonApiKey?{headers:{Authorization:`Bearer ${this.tonApiKey}`,"Content-type":"application/json"}}:{},o=new E.HttpClient({baseUrl:this.isTestnet?G:$,baseApiParams:t});this.client=new E.Api(o),this.stakingContractAddress=e.Address.parse(this.isTestnet?_:I)}async initialize(){var t,e;if(null==(e=null==(t=this.connector.wallet)?void 0:t.account)?void 0:e.address)try{await this.setupWallet(this.connector.wallet)}catch(o){console.error("Error setting up wallet on init:",o),this.deinitialize()}this.connector.onStatusChange(async t=>{var e;if(null==(e=null==t?void 0:t.account)?void 0:e.address)try{await this.setupWallet(t),this.dispatchEvent(new Event("wallet_connected"))}catch(o){console.error("Error in wallet status change:",o),this.deinitialize()}else this.deinitialize(),this.dispatchEvent(new Event("wallet_disconnected"))})}deinitialize(){H("Deinitializing KTON..."),this.walletAddress=void 0,U.jettonWalletAddress=void 0,this.dispatchEvent(new Event("deinitialized"))}async setupWallet(t){var o;try{if(H("Setting up wallet for KTON..."),!(null==(o=null==t?void 0:t.account)?void 0:o.address))throw new Error("No wallet account address provided");this.isTestnet=t.account.chain===B,this.walletAddress=void 0,U.jettonWalletAddress=void 0,this.walletAddress=e.Address.parse(t.account.address);try{U.jettonWalletAddress=await this.getJettonWalletAddress(this.walletAddress)}catch(s){console.warn("Could not get jetton wallet address, will retry on demand:",s)}await this.setupClient(),this.ready=!0,this.dispatchEvent(new Event("initialized"))}catch(s){throw console.error("Error in setupWallet:",s),this.ready=!1,this.dispatchEvent(new Event("error",{detail:s})),s}}async fetchStakingPoolInfo(t){return this.cache.get("poolInfo",async()=>function(t){let o=0;const s=34==t.length;let a=Number(t[o++].num),r=Boolean(t[o++].num),n=BigInt(t[o++].num??0),i=Number(t[o++].num),c=Boolean(t[o++].num),h=Boolean(t[o++].num),l=0;s&&(l=Number(t[o++].num));let d=BigInt(t[o++].num??0),u=0,p=t[o++].tuple,m={borrowers:p[u++].cell,roundId:Number(p[u++].num),activeBorrowers:BigInt(p[u++].num??0),borrowed:BigInt(p[u++].num??0),expected:BigInt(p[u++].num??0),returned:BigInt(p[u++].num??0),profit:BigInt(p[u++].num??0)},g=0,f=t[o++].tuple,y=f[g++].cell??e.Cell.EMPTY,v=Number(f[g++].num),w=BigInt(f[g++].num??0),T=BigInt(f[g++].num??0),k=BigInt(f[g++].num??0),b=BigInt(f[g++].num??0),j=BigInt(f[g++].num??0),E={borrowers:y.toString(),roundId:v,activeBorrowers:w,borrowed:T,expected:k,returned:b,profit:j},q=BigInt(t[o++].num??0),S=BigInt(t[o++].num??0),A=Number(t[o++].num),P=BigInt(0),B=30,$=0;s&&(P=BigInt(t[o++].num??0),B=Number(t[o++].num),$=Number(t[o++].num));let G=e.Cell.fromHex(t[o++].cell).beginParse().loadAddress().toString(),C=BigInt(t[o++].num??0),N=e.Cell.fromHex(t[o++].cell).beginParse().loadAddressAny(),I=BigInt(t[o++].num??0),_=e.Cell.fromHex(t[o++].cell).beginParse().loadAddressAny(),O=BigInt(t[o++].num??0),F=e.Cell.fromHex(t[o++].cell).beginParse().loadAddressAny(),D=Number(t[o++].num),x=e.Cell.fromHex(t[o++].cell).beginParse().loadAddress().toString(),R=Number(t[o++].num),M=e.Cell.fromHex(t[o++].cell).beginParse().loadAddress().toString(),J=e.Cell.fromHex(t[o++].cell).beginParse().loadAddress().toString(),W=e.Cell.fromHex(t[o++].cell).beginParse().loadAddress().toString(),z=t[o++].cell,H=t[o++].cell,U=t[o++].cell,K=BigInt(t[o++].num??0),Q=BigInt(t[o++].num??0);return{state:a,halted:r,totalBalance:n,interestRate:i,optimisticDepositWithdrawals:c,depositsOpen:h,instantWithdrawalFee:l,savedValidatorSetHash:d,previousRound:m,currentRound:E,minLoan:q,maxLoan:S,governanceFee:A,accruedGovernanceFee:P,disbalanceTolerance:B,creditStartPriorElectionsEnd:$,poolJettonMinter:G,poolJettonSupply:C,supply:C,depositPayout:N?N.toString():null,requestedForDeposit:I,withdrawalPayout:_?_.toString():null,requestedForWithdrawal:O,sudoer:F?F.toString():null,sudoerSetAt:D,governor:x,governorUpdateAfter:R,interestManager:M,halter:J,approver:W,controllerCode:z,jettonWalletCode:H,payoutMinterCode:U,projectedTotalBalance:K,projectedPoolSupply:Q}}((await this.client.blockchain.execGetMethodForBlockchainAccount(this.stakingContractAddress.toString(),"get_pool_full_data")).stack),t)}async getCurrentApy(t){if(!this.stakingContractAddress)throw new Error("Staking contract address not set.");try{const e=await this.fetchStakingPoolInfo(t),o=e.interestRate/2**24*(1-e.governanceFee/2**24);return o*481.201171875/2}catch{throw console.error("Failed to get current APY"),new Error("Could not retrieve current APY.")}}async getHistoricalApy(t){const e=this.stakingContractAddress;if(!e)throw new Error("Staking contract address not set.");try{return(await this.cache.get("stakingHistory",()=>this.client.staking.getStakingPoolHistory(e.toString()),t)).apy}catch{throw console.error("Failed to get historical APY"),new Error("Could not retrieve historical APY.")}}async getTvl(t){if(!this.stakingContractAddress)throw new Error("Staking contract address not set.");try{const e=await this.fetchStakingPoolInfo(t),o=e.totalBalance+e.currentRound.borrowed+e.previousRound.borrowed;return Number(o)}catch{throw console.error("Failed to get TVL"),new Error("Could not retrieve TVL.")}}async fetchJettonMasterInfo(t){const e=`${C}/jetton/masters?address=${t}`,o=await fetch(e);if(!o.ok)throw new Error(`HTTP error! Status: ${o.status}`);return await o.json()}async getHoldersCount(t){var e;if(!this.stakingContractAddress)throw new Error("Staking contract address not set.");try{const s=(await this.fetchStakingPoolInfo(t)).poolJettonMinter.toString();try{const o=await this.cache.get(`jettonInfo-${s}`,()=>this.fetchJettonMasterInfo(s),t);if(o.metadata&&o.metadata.holdersCount)return o.metadata.holdersCount;const a=`${N}/jettons/${s}`,r=await fetch(a);if(r.ok){const t=await r.json();if(null==(e=t.details)?void 0:e.holdersCount)return t.details.holdersCount}}catch(o){console.warn("New API failed, falling back to TonAPI:",o)}return(await this.client.jettons.getJettonInfo(s)).holders_count}catch{throw console.error("Failed to get holders count"),new Error("Could not retrieve holders count.")}}async getStakersCount(t){return this.getHoldersCount(t)}async getRates(t){if(!this.stakingContractAddress)throw new Error("Staking contract address not set.");try{const o=await this.fetchStakingPoolInfo(t),s=o.totalBalance,a=o.supply,r=Number(e.fromNano(s))/Number(e.fromNano(a)),n=o.projectedTotalBalance,i=o.projectedPoolSupply,c=Number(e.fromNano(n))/Number(e.fromNano(i));return{TONUSD:await this.getTonPrice(t),KTONTON:r,KTONTONProjected:c}}catch{throw console.error("Failed to get rates"),new Error("Could not retrieve rates.")}}async clearStorageData(){this.cache.clear()}async clearStorageUserData(){this.cache.clear(["network-cache-payouts","network-cache-stakedBalance","network-cache-account"])}async getTonPrice(t){var e,o,s;try{const a=await this.cache.get("tonPrice",()=>this.client.rates.getRates({tokens:["ton"],currencies:["usd"]}),t);return(null==(s=null==(o=null==(e=a.rates)?void 0:e.TON)?void 0:o.prices)?void 0:s.USD)||0}catch{return 0}}async getStakedBalance(t){if(!U.jettonWalletAddress)throw new Error("Jetton wallet address is not set.");const e=U.jettonWalletAddress.toString();try{const o=(await this.cache.get(`stakedBalance-${e}`,()=>this.client.blockchain.execGetMethodForBlockchainAccount(e,"get_wallet_data"),t)).decoded.balance;return H(`Current KTON balance: ${o}`),o}catch{return 0}}async getBalance(t){const e=this.walletAddress;if(!e)throw new Error("Wallet is not connected.");try{const o=await this.cache.get("account",()=>this.client.accounts.getAccount(e.toString()),t);return Math.max(Number(o.balance),0)}catch{return 0}}async getAvailableBalance(t){if(!this.walletAddress)throw new Error("Wallet is not connected.");try{const o=await this.getBalance(t)-Number(e.toNano(M));return Math.max(o,0)}catch{return 0}}async getInstantLiquidityDeprecated(t){return(await this.cache.get("contract-account",()=>this.client.accounts.getAccount(this.isTestnet?_:I),t)).balance}async getInstantLiquidity(t){const e=await this.fetchStakingPoolInfo(t),o=e.totalBalance-e.requestedForWithdrawal;return Number(o)}async stake(t){if(!this.walletAddress||!U.jettonWalletAddress)throw new Error("KTON is not fully initialized.");await this.validateAmount(t);const o=e.toNano(t+x),s=this.preparePayload("stake",t),a=await this.sendTransaction(this.stakingContractAddress,o,s);return H(`Staked ${t} TON successfully.`),a}async stakeMax(){const t=await this.getAvailableBalance(),e=await this.stake(t);return H(`Staked maximum amount of ${t} TON successfully.`),e}async unstake(t){if(!U.jettonWalletAddress)throw new Error("Jetton wallet address is not set.");await this.validateAmount(t);const o=this.preparePayload("unstake",t),s=await this.sendTransaction(U.jettonWalletAddress,e.toNano(R),o);return H(`Initiated unstaking of ${t} KTON.`),s}async unstakeInstant(t){if(!U.jettonWalletAddress)throw new Error("Jetton wallet address is not set.");await this.validateAmount(t);const o=this.preparePayload("unstake",t,!1,!0),s=await this.sendTransaction(U.jettonWalletAddress,e.toNano(R),o);return H(`Initiated instant unstaking of ${t} KTON.`),s}async unstakeBestRate(t){if(!U.jettonWalletAddress)throw new Error("Jetton wallet address is not set.");await this.validateAmount(t);const o=this.preparePayload("unstake",t,!0),s=await this.sendTransaction(U.jettonWalletAddress,e.toNano(R),o);return H(`Initiated unstaking of ${t} KTON at the best rate.`),s}async getActiveWithdrawalNFTs(t){try{const e=await this.cache.get("payouts",()=>this.getPayouts(),t);if(!e)throw new Error("Failed to get payouts.");const o=[];if(e.deposit_payout){const s=await this.cache.get(`payouts-${e.deposit_payout}`,()=>this.getFilteredByAddressNFTs(e.withdrawal_payout,Number(e.cycle_end)),t);o.push(s)}if(e.withdrawal_payout){const s=await this.cache.get(`payouts-${e.withdrawal_payout}`,()=>this.getFilteredByAddressNFTs(e.withdrawal_payout,Number(e.cycle_end)),t);o.push(s)}return o.reduce((t,e)=>t.concat(e),[])}catch(e){throw console.error("Failed to get active withdrawals:",e instanceof Error?e.message:e),new Error("Failed to get active withdrawals.")}}async getFilteredByAddressNFTs(t,e){var o,s,a;try{const r=await this.client.nft.getItemsFromCollection(t),n=Math.floor(e/1e3),i=[];let c=0;for(const t of r.nft_items){if((null==(o=t.owner)?void 0:o.address)===(null==(s=this.walletAddress)?void 0:s.toRawString())){const e=n+c*A+P;i.push({...t,estimatedPayoutDateTime:e,roundEndTime:n,KTONAmount:Number(null==(a=t.metadata.name)?void 0:a.match(/[\d.]+/)[0])||0})}c++}return i}catch(r){return console.error("Failed to get withdrawal history:",r),[]}}preparePayload(t,o,s=!1,a=!1){let r=e.beginCell();switch(t){case"stake":r.storeUint(D,32),r.storeUint(1,64).storeUint(this.partnerCode,64);break;case"unstake":r.storeUint(F,32),r.storeUint(0,64).storeCoins(e.toNano(o)).storeAddress(this.walletAddress).storeMaybeRef(e.beginCell().storeUint(Number(s),1).storeUint(Number(a),1).endCell())}return r.endCell().toBoc().toString("base64")}async getJettonWalletAddress(t){var o;try{const s=(await this.fetchStakingPoolInfo()).poolJettonMinter;if(!s)throw new Error("No jetton minter address found in pool info");const a=await this.client.blockchain.execGetMethodForBlockchainAccount(s.toString(),"get_wallet_address",{args:[t.toString()]});if(!(null==(o=null==a?void 0:a.decoded)?void 0:o.jetton_wallet_address))throw new Error("Invalid response when getting jetton wallet address");return e.Address.parse(a.decoded.jetton_wallet_address)}catch(s){throw console.error("Failed to get jetton wallet address:",s instanceof Error?s.message:s),new Error(`Could not retrieve jetton wallet address: ${s instanceof Error?s.message:String(s)}`)}}async validateAmount(t){if("number"!=typeof t||t<=0)throw new Error("Invalid amount specified")}sendTransaction(t,e,o){const s={validUntil:+new Date+q,messages:[{address:t.toString(),amount:e.toString(),payload:o}]};return this.connector.sendTransaction(s)}async getRoundTimestamps(){try{const t=Math.floor(Date.now()/1e3),e=65536,o=t+e;return{roundStart:o-e,roundEnd:o}}catch(t){return console.error("Error calculating round timestamps",t),{roundStart:0,roundEnd:0}}}static toReadableAddress(t,o=!0){return e.Address.parse(t).toString({bounceable:o})}}t.KTON=U,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=kton-sdk.min.js.map
